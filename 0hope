**MANDATORY IMPLEMENTATION RULES:**

**DB & Entities:** Use Entity Framework Core exclusively for all I/O—no files or external paths. Auto-detect and map all copybooks (e.g., input/output records) to SQL entities/tables with precise field types (e.g., PIC 9(08) → int/long). For input files (e.g., sequential reads), map to dedicated tables. For output files, map to insert/update tables. For I/O or cumulative files (e.g., read-modify-write patterns like stats), create a single-row table (e.g., with Id=1 PK); implement logic to: Read existing row at initialization, accumulate deltas from input processing (e.g., counters from loops), update totals (e.g., add current-run metrics like CPU/ELP), and save back at termination. Preserve all prior values; assume initial seeding via external scripts (e.g., Python for sample data). For report-like output files (e.g., sequential writes of formatted detail lines with headers and values), create a separate multi-row table with fields for header text, detail value, and optional run identifier; insert one row per formatted line during termination processing.
**Business Logic Extraction:**

Identify accumulators (e.g., WA-COUNTS) and populate from inputs (e.g., EVALUATE/ADD in loops).
Map PERFORM sections to async service methods (e.g., init → open/read DB, main process → loop over input tables, term → update cumulative + generate outputs).
Handle modes/flags (e.g., UPDATE/READ from linkage) as runtime params from DB/config.
For outputs like detail reports, generate derived tables/rows (e.g., formatted lines with headers/values); ensure detail inserts use updated cumulative fields post-processing for accurate display.

**Endpoint Derivation:** Analyze FILE-CONTROL, SELECTs, and PERFORM flows to derive minimal, logical REST endpoints (2-4 max, grouped by function—not one per section, not monolithic). Examples: Group input reads/accumulation (e.g., audit stats) → single POST/PUT /process-inputs endpoint (reads tables, accumulates to cumulative); conditional writes (e.g., DIN reapply in UPDATE mode) → dedicated POST /generate-reapply; report outputs (e.g., detail file writes) → GET /generate-display (queries accumulators, inserts formatted rows). Preserve full end-to-end: Endpoints chain if needed (e.g., process-inputs updates cumulative for later display). Use query params for modes; return JSON with status, counts, and output table refs (no raw data—store everything to tables; display GET queries updated detail table reflecting process changes).
**Service Methods:** Fully async with await for DB ops. Include: Parameter validation (detailed errors, e.g., numeric checks), try-catch (specific exceptions like DbUpdateException), logging (entry/exit with context like counts), null/edge case handling (e.g., EOF flags → empty results), business rules from COBOL (e.g., conditionals for writes), data mapping/transformation (e.g., record layouts to entities), input sanitization, and metrics (e.g., Stopwatch for timings). Store all outputs to tables before any response.
**Inputs/Outputs:** Strictly SQL-based—no JSON at any stage. Endpoints/services read from input tables (e.g., audit/DIN equivalents), process with accumulators, update cumulative table, and produce output tables (e.g., reapply/detail). Use transactions for atomicity in updates; responses reference tables only (e.g., row counts, RunId—no DTO data dumps).
**Configs:** Limit appsettings.json to ConnectionStrings, Logging, JwtSettings. No file paths; omit any "FilePaths" section. Populate Configurations folder with all necessary classes (e.g., DbContext, migrations).
**Generics & Robustness:** Ensure code handles variable record counts, errors (e.g., errored-rec counters), and modes dynamically. Seed cumulative tables with zeros if no data; external scripts can populate samples.

***IMPORTANT CONFIGURATION RULES:***

- Do NOT generate any file path references in appsettings.json or anywhere else in the solution.
- The "FilePaths" section must be completely omitted.
- All inputs and outputs must be handled via SQL tables only.
- Any configuration values (e.g., batch job schedules, call modes) must be retrieved from SQL tables at runtime.
- appsettings.json must only contain:
  - ConnectionStrings
  - Logging configuration
  - JwtSettings (if applicable)

**REQUIRED OUTPUT:** Provide a complete C# .NET 8 solution with proper folder structure
"""
